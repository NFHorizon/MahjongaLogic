
#### 麻将的判胡
以一副麻将手牌为例

如果你起手就摸到这样一副牌，朋友恭喜你，你**天胡**了
我们是怎么判断这样一副牌已经胡牌呢？简单地用一个式子来表示，即**3n+2**
**n副面子（面子即顺子、刻子的统称）**，**1副将牌（对子)**
如果想实现对这样一副麻将牌的判胡算法，我们很自然地想到算法的雏形应该是这样的：

* 从手牌中剔除所有的顺子
* 从手牌中剔除所有的刻子
* 从手牌中剔除将牌
* 全剔除完了，胡牌，收钱

作为人类，我们一眼就能看到顺子、刻子和将牌；但是代码里是如何到顺子、刻子和将牌的呢？


##### 麻将牌在代码中的表示形式

为了方便获取牌的花色和牌值，我们用十六进制数的**个位表示牌值**，**十位表示花色**，如一万表示为**0x01**,二筒表示为**0x12**，上述手牌在代码中表示为
```JavaScript
let cards = [0x01, 0x01, 0x01, 0x12, 0x13, 0x14, 0x16, 0x16, 0x16, 0x33, 0x34, 0x35,  0x39, 0x39]
```
在进行胡牌计算时，我们需要**快速地获取某张牌的数量**，因此考虑将手牌转换成另一种形式，矩阵（行序号是花色，列序号是牌值）
```JavaScript
let m = {
        [0]: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        [1]: [0, 1, 1, 1, 0, 3, 0, 0, 0],
        [2]: [0, 0, 1, 1, 1, 0, 0, 0, 2],
}
```
具体的含义如下
```JavaScript
let m = {
    [0（万）]: [一万的数量, 二万的数量, 三万的数量, 四万的数量, 五万的数量，..., 九万的数量],
    [1（筒）]: [一筒的数量, 二筒的数量, 三筒的数量, 四筒的数量, ...，九筒的数量],
    [2（条）]: [幺鸡的数量, 二条的数量, 三条的数量, ...，九条的数量],
}
```
##### 这样表示有什么好处呢？

* 方便获取手牌数目；我们可以快速定位到某张牌，以及这张牌附近的牌，获取数量，以判断是否满足顺子，刻子等条件

* 方便增加/减少手牌；如使用数组形式，要达到同样的目的则需频繁往数组中添加牌、移出牌，这种操作的消耗要大于在矩阵形式中直接增/减数量

* 分治；对于不同的花色，计算的逻辑都是相同的（都是针对1-9的牌值）


------

##### 查表法
- 递归回溯法对手牌进行**实时拆解**而判胡，

- 查表法则预存结果，**以空间换时间**，将**单个花色**满足条件的组合可能以键存于哈希表中

生成的表形式如下（14张牌无赖子情况下一共有21742种组合形式），单个键的含义是这样的：个位表示牌值为1的牌的数量，十位表示牌值为2的牌的数量，以此类推

```lua
{
    ...
    [0x31130033] = true,
    [0x31130114] = true,
    [0x31130141] = true,
    [0x31130222] = true,
    [0x31130303] = true,
    [0x31130330] = true,
    [0x31130411] = true,
    [0x31131113] = true,
    [0x31131140] = true,
    [0x31131221] = true,
    [0x31131410] = true,
    ...
}
```
*表的生成方式：将所有的顺子和刻子，以排列组合中的**组合算法**，形成**3n**（n的范围为0~4）的所有的形式存入表中，然后添加1~9的将牌，形成**3n+2**的所有的形式存入表中*



##### 以查表法实现的判胡算法

建立完表后，可用如下方式判胡：**遍历手牌矩阵，将单个花色的手牌数组拼接成键，判断是否在表中。不在则直接判定为无法胡牌，在则代表该花色是3n或3n+2的组合情况（但不是胡），继续判断下一个花色，统计所有花色下n和将之和，如果n为4, 将为1，即可胡牌**。可以直观地从代码行数上感受到，计算简化了许多，而实际上单个花色的算法复杂度也从O(n^2)降为O(2)，只剩将数组拼接成数字的消耗、查询哈希表的消耗
```JavaScript
static is_hu(m: Matrix) {
    let total_cardcount = this.get_total_cardcount(m)
    if (total_cardcount % 3 !== 2) return false
    // 七对判断
    if (this.belong_qidui(m)) return true
    //各种牌型的次数
    let count_3 = 0 //刻或顺的个数
    let count_2 = 0  //将
    //胡所需满足的3n
    let n = (total_cardcount - 2) / 3
    //满足3N+2的在这里计算
    for (const color of VALID_COLORS) {
        const color_eigen = m[color]
        //跳过没有牌的花色
        if (color_eigen == 0n) continue
        const color_cardcount = this.get_eigen_cardcount(color_eigen)
        if (color_cardcount % 3 === 1 || !this.is_eigen_match(color_eigen, color_cardcount, color)) {
            return false;
        } else {
            count_2 += ((color_cardcount % 3) / 2) >>> 0
            count_3 += (color_cardcount / 3) >>> 0
            if (count_2 > 1) return false
        }
    }
    //满足胡牌队列
    return count_2 == 1 && count_3 == n;
}
```
*如果你详细看了上述代码，让我们聚焦到color_eigen这个变量上，color_eigen表示单个花色的手牌，但此时它已经不是[0, 0, 1, 1, 1, 0, 0, 0, 2]而是0x200011100（数组倒过来），略去了算法中提到的拼接过程，这样做的好处在哪呢？最直接的优点就是，省去拼接数组的消耗*



##### 查表法的启示：手牌的另一种表示形式

先前的实现中，我们在计算胡牌时使用了矩阵来表示手牌
```JavaScript
let m = {
        [0]: [3, 0, 0, 0, 0, 0, 0, 0, 0],
        [1]: [0, 1, 1, 1, 0, 3, 0, 0, 0],
        [2]: [0, 0, 1, 1, 1, 0, 0, 0, 2],
}
```
受查表法启发，考虑一种新的表示方式，类比于位图法（bitmap），使用了16进制数的每个位来承载信息。在这里，我使用了一个名词“eigen”（特征值）来指代单个花色的手牌对应的值
```JavaScript
let m = {
        [0]: 0x000_000_003,
        [1]: 0x000_301_110,
        [2]: 0x200_011_100,
}
```

对于查表法，位图形式的手牌显然比矩阵形式契合得多，我们节省了将数组拼接成“eigen”这个消耗不小的操作

但同时，相比于矩阵形式可直接使用数组下标来获取特定牌的数量，位图形式需要对“eigen”进行位操作才能获取，这是额外的工作量

文章的最后部分继续讲述这种表示方式的其他好处，你懂的，就是位操作之类的，没什么玄乎的



##### 支持癞子的查表法
癞子在棋牌的算法中永远都扮演着一个混乱的引入者，但鉴于篇幅，不展开推导细节，我们只说三个结论

1. 不论是癞子胡还是普通胡，都无需判断面子的数量，这个条件和位于表中这个条件重复了，最终的胡牌的约束条件统一为
    * **持有癞子数是否大于所需的癞子数，普通胡即为所需癞子数为0的情况**
    * **有1对将牌**
    * **所有花色的eigen都必须位于表中**
2. 17张麻将的表包含了14张麻将的表，最终统一使用17张牌情况下建成的表
3. 表扩展为如下形式，value从true改为数字，表示这个牌型需要的癞子数，普通胡的表即为表中value为0的部分

```JavaScript
{
    [0x244311020]=0,
    [0x244311200]=0,
    [0x244313000]=0,
    [0x000000001]=1,
    [0x000000010]=1,
    [0x000000100]=1,
    [0x000001000]=1,
    [0x000010000]=1,
    ...
}
```
最终的算法如下，还是非常简单，非常枯燥。而代价就是我们的表达到了66万个键（17张牌，含癞子）这个数量级，好在66万个键内存占用也不大，而这已经囊括了世间所有麻将判胡所需的表了（除去特殊牌型）
```typescript
static match_shape(m: Matrix, max_lack: number) {
    //各种牌型的次数
    let count_2 = 0  //将
    let total_need = 0
    //满足3N+2的在这里计算
    for (const color of VALID_COLORS) {
        const color_eigen = m[color]
        if (color_eigen == 0n) continue
        const color_cardcount = this.get_eigen_cardcount(color_eigen)
        const color_need = this.is_eigen_match(color_eigen, color)
        if (color_need === Infinity) {
            return false
        }
        total_need += color_need
        const total_lack = total_need - m[LAIZI_COUNT]
        if (total_lack > max_lack) {
            return false
        }
        if ((color_cardcount + color_need) % 3 === 2) {
            count_2 += 1
        }
        if (total_lack > max_lack + 1 - count_2) {
            return false
        }
    }
    //满足胡牌队列
    return true
}
```



##### 听牌算法

听牌算法有两个目的

- 计算该玩家是否在听牌状态
- 计算可听的牌，并推送给玩家，优化玩家游戏体验

在之前的做法中，我们会在玩家每次手牌变化后，都计算一次可听的牌，如果可听的牌大于0，那么该玩家也就处于听牌状态了

问题在于，计算玩家可听的牌，将消耗较多的算力，能否做一些剪枝处理，只在必要时，才去计算可听的牌呢？

在新的麻将算法库中，我们继续扩展判胡算法的定义，会发现

- **胡牌相当于不允许缺少癞子的判胡算法**
- **听牌相当于可缺1张癞子的判胡算法**

于是判断听牌就可以按如下方式实现

```typescript
static is_ting(m: Matrix) {
    if (this.get_total_cardcount(m) % 3 !== 1) {
        console.error("is_laizi_ting 0", this.matrix_to_cards(m))
        return false
    }
    m = this.shelter_laizi(m)

    return this.match_shape(m, 1)
}
```

原先的流程就可以优化为，先判断玩家是否处于听牌状态，如果是的话才进一步计算可听的牌。只此一条就可以节约服务端大量算力（根据经验，计算可听的牌在火焰图中占比不小）



##### 推荐出牌算法（AI）

出哪张牌好？这个问题在不同麻将里有不同的解法，但我们考虑的是通用的方案；这个方案最好还是量化的，以便为以后添加强化学习留接口。考虑如下两个做法

- 去掉该牌后，剩下的牌价值最高
- 计算所有牌的价值，打出最低的那张

在推荐出牌时，我选用了第二种做法；而在推荐操作时，我选用了第一种做法。这两者的计算过程有一些重叠的部分，因此我只举第二种做法为例子。

1. 在行牌过程中，维护一个玩家视角下的剩余牌记录表，每张牌的初始剩余数量都是4，再随着牌局变化扣去场上已明示的牌，得到猜测值（你无法得知其他家的手牌和暗杠）
2. 算出手牌的**全拆解**可能性，这意味着即使完成某路径的拆解，也必须得尝试另一条路径，以便了解牌的全部可能性。这副牌也许已经听了，也许只是一副零零散散的烂牌。查表法？这个场景下你可以忘了它了。我们使用如下方式进行拆解
   - 剔除面子
   - 剔除搭子（搭子即为缺一张可成为面子的组合，如5万6万, 1万2万，6万8万），将牌也算作搭子，因为补一张可变成面子
   - 剩下的牌称为孤张
3. 评估牌的价值，我们定义了一个牌组合的分值表，如刻子1.1，边张搭子0.7，夹听搭子0.7，听两侧的搭子0.8，将牌0.9等。如牌在某个拆解可能性中，则与这个分值进行运算。牌参与的拆解可能性越多，则分数越高。搭子和孤张还要额外将缺少的那张牌的剩余数量除于固定值作为分值的一个系数，以随着牌局发展而动态调节。运算过程无需严密，只需体现出牌与牌之间的优先级
4. 选出价值最低的那张牌，或者在较低的几张牌间随机抽取

*该分值表可以在后期训练，以胡牌所需步数评估*



由递归回溯法得到的经验是，拆解手牌过程中，单次操作的消耗并不高，最有效的优化是减少递归或循环次数。在全拆解中，递归次数没有很大的优化空间；而循环次数可以由接下来引入的手牌剔除算法减少。

*不做拆解可不可以？能否利用癞子胡生成的表来评估一副牌的价值？这个问题留待下次解决*



##### **手牌剔除算法**

我们在矩阵表示法里是如何判断手牌的包含关系的
* 是否包含一组刻子：获取该牌值的数量，判断是否大于3
* 是否包含一组顺子：获取顺子的每张牌的数量，判断每一张是否大于1
* 是否包含另一副牌：获取另一副牌每张牌的数量，再获取手牌对应的牌的数量，看是否大于

显然，算法复杂度为从O(1)到O(n)不等



我们又是如何从手牌中删去牌的
* 删去刻子：获取该牌值的数量，判断是否大于3，然后减去3
* 删去顺子：获取顺子的每张牌的数量，判断每一张是否大于1，然后减去1
* 删去另一副牌：获取另一副牌每张牌的数量，再获取手牌对应的牌的数量，看是否大于，然后减去

算法复杂度没有变多，也没有变少



**别忘了，我们已经使用了新的手牌表示形式，在单个花色中，删牌操作相当于做减法**

假设我们现在万花色的牌是0x213121010，我们想从中剔除0x103011000这些牌，那么只需要

```JavaScript
0x213121010n - 0x103011000n  = 0x110020010
```
相当简单，相当枯燥
什么，不够删时怎么办，比如

```JavaScript
0x211021010n - 0x103011000n  = 0x10E010010
```
这个结果可毫无意义

因此，在做减法之前，我们需要判断包含关系，保证一副牌的每一张牌的数量，都大于另一副牌

- 已知，两数间做减法，某位不够减时将发生借位，0x12 - 0x03 结果为 0x0F
- 已知，绝大部分麻将游戏中，最多有4张相同的牌



让我们来计算两个区间

- 发生借位时，该位数字可能的区间：(0 - 4 + 16）~ （ 3 - 4 + 16） =  (12 ~ 15）

- 未发生借位时，该位数字可能的区间： (0 ~ 4)

  

让我们来温习0~15的数的二进制表示

```
0b0000  0
0b0001  1
0b0010  2
0b0011  3
0b0100  4

0b0101  5
0b0110  6
0b0111  7
0b1000  8
0b1001  9
0b1010  10
0b1011  11

0b1100  12
0b1101  13
0b1110  14
0b1111  15
```
是否注意到了，0~4的数字，第四位（0x8）一定为0，而12~15的数字，第四位一定为1，我想，你心中应该已经有了答案
```JavaScript
//n结尾的数字在ts中表示bigint类型，在js上，对于int类型，位操作只支持32位以下
//满足此等式即为包含
（0x211021010n - 0x103011000n）& 0x888888888n == 0
```
在此特殊情形下，减法发生借位时，结果中某位，与0x8的位与一定为1

首先，我们将数组间的剔除计算，退化为数字间的减法，相当于并行化了该操作；其次，我们保证了这个减法的合法性。在理论上，该方式在此特殊领域内是最高效的



##### 其他利用位运算性质的例子

算番时计算根的数量（非完整代码）
```JavaScript
const res = color_eigen & 0x444444444n;
```
判断是否是七对牌型（非完整代码）
```JavaScript
color_eigen & 0x111111111n
```
判断十三幺
```JavaScript
static belong_shisanyao(m: Matrix) {
    if (this.get_total_cardcount(m) !== 14) { return false; }

    for (const color of VALID_COLORS) {
        const color_eigen = m[color]
        let match_eigen = 0n
        if (color == COLOR_WAN || color == COLOR_TONG || color == COLOR_TIAO) match_eigen = 0x100000001n
        else if (color == COLOR_FENG) match_eigen = 0x1111n
        else if (color == COLOR_JIAN) match_eigen = 0x111n

        if (!this.is_eigen_include(color_eigen, match_eigen)) {
            return false;
        }
    }
    return true;
}
```



#### 后记

基于一些简单的数字性质，我们创建了新的算法和新数据格式，在此基础上，我们使用了Rust以及TypeScript语言实现了新的麻将算法库，它的性能颇具优势

- 在Rust版本上，查表判胡法（含癞子）的运行速度达到了3000万次/秒，33ns/次（i5 7500 cpu)；TS版本达到了250万次/秒
- 可用于对比的数据是，项目中原有的递归回溯法的c++实现版本最高只能达到500万次/秒（不含癞子）
- 仅听牌算法优化一项，预计可使服务端节省50%以上算力
- 在新的剔除算法下，AI出牌和摆牌算法的计算效率可达原先的数倍（也许更高）

更重要的是，最终麻将算法库在1000行的容量中实现了支持癞子的胡牌表生成、判胡、听牌计算、推荐出牌/推荐操作、番数计算，维护成本不高。因此可以说是一个简单而又高效的解决方案。
